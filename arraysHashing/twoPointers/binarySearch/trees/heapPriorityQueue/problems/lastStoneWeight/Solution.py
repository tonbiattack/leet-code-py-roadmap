import heapq

# 問題文の概要
# 目的: 複数の石が与えられており、各石には一定の重さがあります。この石を2つずつ選んでぶつけ合い、
# 最終的に1つか0個の石が残るまで操作を続け、残った石の重さを求める問題です。

# 操作のルール:
# 1. 最も重い2つの石を選びます。
# 2. 石の重さが等しい場合: その2つの石は互いに破壊し合い、消滅します。
# 3. 石の重さが異なる場合: 重い石から軽い石の重さを引いた新しい石が生成され、
#    その重さ分だけ軽くなった状態で再び石の集合に戻されます。
# 4. この操作を、1つ以下の石になるまで繰り返します。
# 最終結果:
# 最後に1つの石が残っていればその重さを、残っていなければ0を返します。

class Solution:
    def lastStoneWeight(self, stones):
        # 最大ヒープを作成するため、stones の各値をマイナスにして保存します
        # heapq モジュールのヒープはデフォルトで最小ヒープなので、負数にして最大ヒープのように使います
        stones = [-stone for stone in stones]  # 各石の重さを負の値に変換
        
        # stones リストをヒープに変換します。これでリストがヒープとして扱えるようになります
        heapq.heapify(stones)  # 最小ヒープに変換（負の値にしているため最大ヒープとして扱える）
        
        # ヒープに1個以上の石が残っている限り、処理を続けます
        while len(stones) > 1:
            # ヒープから最大の石（実際には負数での最小値）を2つ取り出します
            first = -heapq.heappop(stones)  # 1つ目の最大の石を取り出す（正の値に戻します）
            second = -heapq.heappop(stones) # 2つ目の最大の石を取り出す（正の値に戻します）
            
            # 2つの石が異なる重さであれば、その差の重さの石を新たにヒープに追加します
            if first != second:
                # 差の重さの石を負数にして再度ヒープに追加します
                heapq.heappush(stones, -(first - second))
        
        # ヒープが空であれば 0 を返し、残っている石の重さを返します
        return -stones[0] if stones else 0

# 使用例
stones = [2, 7, 4, 1, 8, 1]
sol = Solution()
print(sol.lastStoneWeight(stones))  # 出力は1になります
