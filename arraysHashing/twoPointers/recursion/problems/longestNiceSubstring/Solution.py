# この問題「Longest Nice Substring」は、文字列操作を通して条件を満たす最長の部分文字列を探す問題です。問題の内容を詳しく解説します。

# 問題概要
# 「ナイスな部分文字列」を見つけることがテーマです。具体的には、次の条件を満たす部分文字列を「ナイスな部分文字列」と定義します：

# 部分文字列の中にある各小文字が、その大文字版も含まれていること。
# 例えば、文字「a」が含まれているならば「A」も含まれなければなりません。また「b」が含まれているならば「B」も同様です。
# 問題の要件
# 与えられた文字列 s の中で、最長の「ナイスな部分文字列」を見つけることが求められます。
# 「ナイスな部分文字列」が複数ある場合は、そのうち最初に出現するものを返します。
# ナイスな部分文字列が存在しない場合は空文字列 ("") を返します。
# 入力と出力
# 入力: 文字列 s（長さ n、1 <= n <= 100）
# 出力: 最長の「ナイスな部分文字列」
# 例
# 入力例 1
# plaintext
# コードをコピーする
# s = "YazaAay"
# 部分文字列 "aAa" は「ナイス」です。
# 部分文字列 "azaAa" も「ナイス」であり、かつ長さもより長いので、これが最長です。
# 出力: "aAa"
# 入力例 2
# plaintext
# コードをコピーする
# s = "Bb"
# 部分文字列 "Bb" は「ナイス」です。
# 出力: "Bb"
# 入力例 3
# plaintext
# コードをコピーする
# s = "c"
# 「ナイスな部分文字列」が存在しないため、出力は空文字列 ("") です。
# 出力: ""
# ポイント
# この問題の重要な点は以下の通りです：

# 部分文字列の探索

# 部分文字列全体を探索する必要があるため、各部分文字列に対してナイスであるかどうかを確認する処理が求められます。
# ナイスかどうかの判定方法

# 部分文字列がナイスであるかどうかを判断するために、各文字がその逆のケース（小文字なら大文字、大文字なら小文字）も含まれているかを確認します。
# 効率の工夫

# 暴力的にすべての部分文字列を確認するのではなく、条件を満たさない文字を含む部分で分割して再帰的に確認する手法などが有効です。
# 解法のヒント
# この問題を解くには、部分文字列を検証しながら効率的に探索する方法を考える必要があります。ナイスでない部分がある場合、その部分を含まない範囲での部分文字列を再帰的に確認するなどのテクニックが役立つでしょう。


class Solution:
    def longestNiceSubstring(self, s: str) -> str:
        # ベースケース（境界条件）
        # 入力文字列が空の場合は空文字列を返す
        if not s:
            return ""  # 空文字列を返す

        # 入力文字列内のすべての文字をセットに変換して、各文字の大文字・小文字の存在を確認しやすくする
        ss = set(s)

        # 文字列内の各文字とそのインデックスに対してループを行う
        for i, c in enumerate(s):
            # 現在の文字 c のスワップケース（大文字なら小文字、小文字なら大文字）を確認
            # もしその文字がセット内に存在しない場合、Nice Substringの条件を満たさないため分割する
            if c.swapcase() not in ss:
                # 入力文字列を現在の位置で分割し、左側と右側をそれぞれ再帰的に呼び出して処理
                s0 = self.longestNiceSubstring(s[:i])  # 左部分の再帰呼び出し
                s1 = self.longestNiceSubstring(s[i+1:])  # 右部分の再帰呼び出し

                # 長さが長い方を返す
                return max(s0, s1, key=len)

        # すべての文字が大文字と小文字両方存在する場合は、元の文字列をそのまま返す
        return s


sol = Solution()
print(sol.longestNiceSubstring("YazaAay"))
